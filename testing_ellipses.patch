diff --git a/src/Engine/Task/Ordered/AATIsoline.hpp b/src/Engine/Task/Ordered/AATIsoline.hpp
index 39df873c51..44643d4f4a 100644
--- a/src/Engine/Task/Ordered/AATIsoline.hpp
+++ b/src/Engine/Task/Ordered/AATIsoline.hpp
@@ -20,7 +20,7 @@ class AATIsoline
 {
 protected:
   /** ellipse representing the isoline segment */
-  const GeoEllipse ell;
+  GeoEllipse ell;
 
 public:
   /**
diff --git a/src/Engine/Task/Ordered/AATIsolineSegment.cpp b/src/Engine/Task/Ordered/AATIsolineSegment.cpp
index d8b3bbbd82..57f9652f6d 100644
--- a/src/Engine/Task/Ordered/AATIsolineSegment.cpp
+++ b/src/Engine/Task/Ordered/AATIsolineSegment.cpp
@@ -5,6 +5,8 @@
 #include "Task/PathSolvers/IsolineCrossingFinder.hpp"
 #include "Util/Tolerances.hpp"
 
+#include "Points/AATPoint.hpp"
+
 AATIsolineSegment::AATIsolineSegment(const AATPoint &ap,
                                      const FlatProjection &projection) noexcept
   :AATIsoline(ap, projection)
@@ -34,3 +36,27 @@ AATIsolineSegment::Parametric(const double t) const noexcept
   const auto r = t * (t_up - t_down) + t_down;
   return ell.Parametric(r);
 }
+
+TestSegment::TestSegment(const AATPoint &ap,
+              const FlatProjection &projection) noexcept
+:AATIsolineSegment(ap, projection)
+{
+  GeoPoint x = ap.GetTargetLocation();
+  GeoPoint x2 = GeoPoint(x.longitude, x.latitude+Angle::Degrees(0.1));
+
+  ell = GeoEllipse(ap.GetPrevious()->GetLocationRemaining(),
+                   ap.GetNext()->GetLocationRemaining(),
+                   x2, projection);
+
+  IsolineCrossingFinder icf_up(ap, ell, 0, 0.5);
+  IsolineCrossingFinder icf_down(ap, ell, -0.5, 0);
+
+  t_up = icf_up.solve();
+  t_down = icf_down.solve();
+
+  if (t_up < -0.5 || t_down < -0.5) {
+    t_up = 0;
+    t_down = 0;
+    // single solution only
+  }
+}
diff --git a/src/Engine/Task/Ordered/AATIsolineSegment.hpp b/src/Engine/Task/Ordered/AATIsolineSegment.hpp
index d958580749..e3ff4cf34b 100644
--- a/src/Engine/Task/Ordered/AATIsolineSegment.hpp
+++ b/src/Engine/Task/Ordered/AATIsolineSegment.hpp
@@ -16,6 +16,7 @@
  */
 class AATIsolineSegment: public AATIsoline
 {
+  protected:
   double t_up;
   double t_down;
 
@@ -49,3 +50,10 @@ public:
   [[gnu::pure]]
   GeoPoint Parametric(double t) const noexcept;
 };
+
+class TestSegment : public AATIsolineSegment {
+public:
+  TestSegment(const AATPoint &ap,
+              const FlatProjection &projection) noexcept;
+
+};
diff --git a/src/Look/TaskLook.cpp b/src/Look/TaskLook.cpp
index b55147f980..1d533514d7 100644
--- a/src/Look/TaskLook.cpp
+++ b/src/Look/TaskLook.cpp
@@ -26,6 +26,7 @@ TaskLook::Initialise()
   arrow_inactive_pen.Create(Layout::ScalePenWidth(1), task_color);
 
   isoline_pen.Create(Pen::DASH2, Layout::ScalePenWidth(1), isoline_color);
+  _95p_isoline_pen.Create(Pen::SOLID, Layout::ScalePenWidth(1), Color(0x00, 0xb0, 0x00));
 
   bearing_pen.Create(Layout::ScalePenWidth(2),
                   HasColors() ? bearing_color : COLOR_BLACK);
diff --git a/src/Look/TaskLook.hpp b/src/Look/TaskLook.hpp
index f19a5c9ea6..e6f1d168ab 100644
--- a/src/Look/TaskLook.hpp
+++ b/src/Look/TaskLook.hpp
@@ -17,6 +17,7 @@ struct TaskLook {
   Pen arrow_active_pen;
   Pen arrow_inactive_pen;
   Pen isoline_pen;
+  Pen _95p_isoline_pen;
 
   Pen bearing_pen;
   Pen best_cruise_track_pen;
diff --git a/src/Renderer/TaskPointRenderer.cpp b/src/Renderer/TaskPointRenderer.cpp
index 371b35ee17..b7f82cbbc9 100644
--- a/src/Renderer/TaskPointRenderer.cpp
+++ b/src/Renderer/TaskPointRenderer.cpp
@@ -11,6 +11,9 @@
 #include "Math/Screen.hpp"
 #include "OZRenderer.hpp"
 
+//delete me
+#include "Geo/GeoEllipse.hpp"
+
 TaskPointRenderer::TaskPointRenderer(Canvas &_canvas,
                                      const WindowProjection &_projection,
                                      const TaskLook &_task_look,
@@ -138,6 +141,30 @@ TaskPointRenderer::DrawTaskLine(const GeoPoint &start,
   canvas.DrawPolyline(Arrow, 3);
 }
 
+inline std::unique_ptr<std::array<BulkPixelPoint, TaskPointRenderer::isoline_polyline_size>>
+TaskPointRenderer::IsolinePixels(const AATIsolineSegment &seg) const noexcept
+{
+  if (!seg.IsValid())
+    return nullptr;
+
+  GeoPoint start = seg.Parametric(0);
+  GeoPoint end = seg.Parametric(1);
+
+  if (m_proj.GeoToScreenDistance(start.DistanceS(end)) <= 2)
+    return nullptr;
+
+  std::array<BulkPixelPoint, isoline_polyline_size> p;
+  p.front() = m_proj.GeoToScreen(start);
+  p.back() = m_proj.GeoToScreen(end);
+
+  for (unsigned i = 1; i < p.size()-1; ++i) {
+    auto t = static_cast<double>(i) / (p.size()-1);
+    GeoPoint ga = seg.Parametric(t);
+    p[i] = m_proj.GeoToScreen(ga);
+  }
+  return std::make_unique<std::array<BulkPixelPoint, isoline_polyline_size>>(p);
+}
+
 inline void
 TaskPointRenderer::DrawIsoline(const AATPoint &tp) noexcept
 {
@@ -145,30 +172,30 @@ TaskPointRenderer::DrawIsoline(const AATPoint &tp) noexcept
     return;
 
   AATIsolineSegment seg(tp, flat_projection);
-  if (!seg.IsValid())
-    return;
 
-  GeoPoint start = seg.Parametric(0);
-  GeoPoint end = seg.Parametric(1);
+  if (auto pixels = IsolinePixels(seg)) {
+    canvas.Select(task_look.isoline_pen);
+    canvas.SetBackgroundTransparent();
+    canvas.DrawPolyline(pixels->data(), pixels->size());
+    canvas.SetBackgroundOpaque();
+  }
+}
 
-  if (m_proj.GeoToScreenDistance(start.DistanceS(end)) <= 2)
+inline void
+TaskPointRenderer::Draw95pIsoline(const AATPoint &tp) noexcept
+{
+  if (!tp.valid() || !IsTargetVisible(tp))
     return;
 
-  BulkPixelPoint screen[21];
-  screen[0] = m_proj.GeoToScreen(start);
-  screen[20] = m_proj.GeoToScreen(end);
+//  AATIsolineSegment seg(tp, flat_projection);
+  TestSegment       seg(tp, flat_projection);
 
-  for (unsigned i = 1; i < 20; ++i) {
-    constexpr double twentieth = 1.0 / 20.0;
-    auto t = i * twentieth;
-    GeoPoint ga = seg.Parametric(t);
-    screen[i] = m_proj.GeoToScreen(ga);
+  if (auto pixels = IsolinePixels(seg)) {
+    canvas.Select(task_look._95p_isoline_pen);
+    canvas.SetBackgroundTransparent();
+    canvas.DrawPolyline(pixels->data(), pixels->size());
+    canvas.SetBackgroundOpaque();
   }
-
-  canvas.Select(task_look.isoline_pen);
-  canvas.SetBackgroundTransparent();
-  canvas.DrawPolyline(screen, 21);
-  canvas.SetBackgroundOpaque();
 }
 
 inline void
@@ -235,6 +262,8 @@ TaskPointRenderer::Draw(const TaskPoint &tp, Layer layer) noexcept
     DrawOrdered(otp, layer);
     if (layer == Layer::SYMBOLS) {
       DrawIsoline(atp);
+      // if MapSettings map_settings.show_95_percent_rule_helpers
+      Draw95pIsoline(atp);
       DrawBearing(tp);
       DrawTarget(tp);
     }
diff --git a/src/Renderer/TaskPointRenderer.hpp b/src/Renderer/TaskPointRenderer.hpp
index c08b84f27b..9a882a1533 100644
--- a/src/Renderer/TaskPointRenderer.hpp
+++ b/src/Renderer/TaskPointRenderer.hpp
@@ -3,6 +3,8 @@
 
 #pragma once
 
+#include <array>
+#include <memory>
 #include "Geo/GeoPoint.hpp"
 #include "Geo/Flat/FlatBoundingBox.hpp"
 #include "MapWindow/MapCanvas.hpp"
@@ -17,6 +19,8 @@ class OrderedTaskPoint;
 class AATPoint;
 class FlatProjection;
 struct TaskLook;
+struct BulkPixelPoint;
+class AATIsolineSegment;
 
 class TaskPointRenderer
 {
@@ -47,6 +51,7 @@ private:
 
   bool task_finished = false;
   bool mode_optional_start = false;
+  constexpr static int isoline_polyline_size = 21;
 
 public:
   enum class Layer : uint_least8_t {
@@ -113,6 +118,10 @@ private:
   void DrawTarget(const TaskPoint &tp) noexcept;
   void DrawTaskLine(const GeoPoint &start, const GeoPoint &end) noexcept;
   void DrawIsoline(const AATPoint &tp) noexcept;
+  void Draw95pIsoline(const AATPoint &tp) noexcept;
+  std::unique_ptr<std::array<BulkPixelPoint, isoline_polyline_size>> 
+  IsolinePixels(const AATIsolineSegment &seg) const noexcept;
+
   void DrawOZBackground(Canvas &canvas, const OrderedTaskPoint &tp,
                         int offset) noexcept;
   void DrawOZForeground(const OrderedTaskPoint &tp, int offset) noexcept;
